基因算法部分来至于：https://github.com/bz51/GeneticAlgorithm， 也可直接点上面的genetic跳过去

-----
-----

## 采用遗传算法解决负载均衡调度问题
算法都是用来解决实际问题的，到此为止，我想你对遗传是算法已经有了个全面的认识，下面我们就用遗传算法来解决一个实际问题——负载均衡调度问题。

> 假设有N个任务，需要负载均衡器分配给M个服务器节点去处理。每个任务的任务长度、每台服务器节点(下面简称“节点”)的处理速度已知，请给出一种任务分配方式，使得所有任务的总处理时间最短。

## 数学建模
拿到这个问题后，我们首先需要将这个实际问题映射成遗传算法的数学模型。

### 任务长度矩阵（简称：任务矩阵）
我们将所有任务的任务长度用矩阵tasks表示，如：
> Tasks={2,4,6,8}

那么，tasks[i]中的i表示任务的编号，而tasks[i]表示任务i的任务长度。

### 节点处理速度矩阵（简称：节点矩阵）
我们将所有服务器节点的处理速度用矩阵nodes表示，如：
> Nodes={2,1}

那么，nodes[j]中的j表示节点的编号，而nodes[j]表示节点j的处理速度。

### 任务处理时间矩阵
当 **任务矩阵Tasks**和**节点矩阵Nodes**确定下来之后，那么所有任务分配给所有节点的任务处理时间都可以确定了，我们用矩阵**timeMatrix**表示，它是一个二维数组：
> 1 2 <br>
2 4<br>
3 6<br>
4 8

timeMatrix[i][j]表示将任务i分配给节点j处理所需的时间，它通过如下公式计算：
> timeMatrix[i][j] = tasks[i]/nodes[j]

### 染色体
通过上文我们知道，每次进化都会产生N条染色体，每一条染色体都是当前问题的一个可行解，可行解由多个元素构成，每个元素称为染色体的一个基因。下面我们就用一个染色体矩阵来记录算法每次进化过程中的可行解。

一条染色体的构成如下：
> chromosome={1,2,3,4}

一条染色体就是一个一位数组，一位数组的下标表示任务的编号，数组的值表示节点的编号。那么chromosome[i]=j的含义就是：将任务i分配给了节点j。

上面的例子中，任务集合为Tasks={2,4,6,8}，节点集合为Nodes={2,1}，那么染色体chromosome={3,2,1,0}的含义是：
- 将任务0分配给3号节点
- 将任务1分配给2号节点
- 将任务2分配给1号节点
- 将任务3分配给0号节点

### 适应度矩阵
通过上文可知，在遗传算法中扮演者“上帝”角色的是适应度函数，它会评判每一条染色体的适应度，并保留适应度高的染色体、淘汰适应度差的染色体。那么在算法实现时，我们需要一个适应度矩阵，记录当前N条染色体的适应度，如下所示：
> adaptability={0.6, 2, 3.2, 1.8}

adaptability数组的下标表示染色体的编号，而adaptability[i]则表示编号为i的染色体的适应度。

在负载均衡调度这个实例中，我们将N个任务执行总时长作为适应度评判的标准。当所有任务分配完后，如果总时长较长，那么适应度就越差；而总时长越短，则适应度越高。

### 选择概率矩阵
通过上文可知，每次进化过程中，都需要根据适应度矩阵计算每一条染色体在下一次进化中被选择的概率，这个矩阵如下所示：
> selectionProbability={0.1, 0.4, 0.2, 0.3}

矩阵的下标表示染色体的编号，而矩阵中的值表示该染色体对应的选择概率。其计算公式如下：
> selectionProbability[i] = adaptability[i] / 适应度之和

## 遗传算法的实现
> 上述一切知识点铺垫完成之后，接下来我们就可以上代码了，相信Talk is cheap, show you the code!

```js
/**
 * 遗传算法
 * @param iteratorNum 迭代次数
 * @param chromosomeNum 染色体数量
 */
function gaSearch(iteratorNum, chromosomeNum) {
    // 初始化第一代染色体
    var chromosomeMatrix = createGeneration();

    // 迭代繁衍
    for (var itIndex=1; itIndex<iteratorNum; itIndex++) {
        // 计算上一代各条染色体的适应度
        calAdaptability(chromosomeMatrix);

        // 计算自然选择概率
        calSelectionProbability(adaptability);

        // 生成新一代染色体
        chromosomeMatrix = createGeneration(chromosomeMatrix);

    }
}
```
代码一来，一切都清晰了，似乎不需要过多的解释了。
上面是遗传算法最主要的框架，其中的一些细节封装在了一个个子函数中。在理解了遗传算法的原理后，我想代码不需要我作过多的解释了吧～完整的代码在我的Github上，欢迎Star。

## 结果展示     
![Image](https://github.com/bz51/GeneticAlgorithm/tree/master/img/result.png)     
上述算法一共进行了100次进化，每次进化都会生成100条染色体。图中的横坐标表示进化次数，而纵坐标表示任务执行时间。
从图中我们可以看到，当进化约20次的时候，算法渐渐收敛于最优解。

-----
-----
